1664042
梅本春輝

1)ソースプログラムについて
　①では、hを求める計算式である(横画素数*縦画素数)/(想定する階調数)によりhを求める。②では、forループを用いて、全画素の階調値を走査しながら、その値が現在の一時的なfmaxよりも大きければ、fmaxを更新し、fminよりも小さければ、fminを更新する、そうでなければなにもしないようにすることで、image[0]のmax,fminを求める。③では、forループを用いて、②で求めた、fminからfmaxまでfをインクリメントしながら、そのターゲットとなるfと等しい階調値の画素をgの値に置き換えていく。gは①で求めたhの数同じ値で変換するとインクリメントされる。これにより、image[1]に、平滑化後の階調値を格納する。

2)実験結果について
　org1.pgmに関しては、処理結果が、示された処理例のように、より画像のコントラストがはっきりし、くっきりとした画像に変換された。
　org2.pgmは、夜に住宅街の道路の写真を撮影したもので、全体的に暗くなにが写っているか視覚的には判断しづらい。しかし、処理後の画像では、階調値の差がはっきり分かり、路面標示や電柱の存在が、視認できた。

3)感想・意見など
　ヒストグラム平滑化のアルゴリズムはそれほど複雑なものではなく、プログラムも簡単に実装することができた。しかし、実行結果をみてみると、特にout2.pgmでは、暗視ゴーグルをつけたかのように劇的に変化しており、我々学生でも実装できるようなアルゴリズムでも、一定の性能があることに感動した。ヒストグラム平滑化では、すべての階調値に同数の画素が割り当てられるため、org2.pgmのような黒に偏っているような画像では、うまく機能しないかと考えていたが、黒に偏っていたとしても、階調値がすこしでも異なっていれば、うまくコントラストを表現できるようだ。さらに、org2.pgmを、より原画像に近く、かつコントラストを表現する方法として、0~255に平均するのではなく、黒よりの階調値に限定してヒストグラム平滑化を行うことが考えられる。
